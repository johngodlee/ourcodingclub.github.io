<!DOCTYPE html>
<html lang="en-GB">
	<head>
    	<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Analysing Earth science and climate data with Iris</title>
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- CSS -->
<link rel="stylesheet" href="/css/main.css"/>
<link rel="stylesheet" href="/css/owlcarousel/owl.carousel.css">
<link rel="stylesheet" href="/css/owlcarousel/owl.theme.default.css">

<!-- JS -->
<script src="https://use.fontawesome.com/4dd22df1f8.js"></script>
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<script src="/scripts/accordion.js"></script>
<script src="/scripts/jquery.counterup.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/waypoints/2.0.5/waypoints.min.js"></script>
<script src="/scripts/ticker.js"></script>

	</head>
	<body>
    	<header class="header">
	<div class="navigation-bar">
		<div id="navigation-container">
			
				<a class="logo" href="/">
  <img src="/assets/img/logos/logo_stack.svg" alt="Coding Club logo">
</a>

			
			<nav>
				<label for="hamburger">☰</label>
				<input type="checkbox" id="hamburger">
				<ul>
					
						
					<li class="item item-nav">
						<a href="/">Home</a>
					</li>
					
						
					<li class="item item-nav">
						<a href="/tutorials.html">Tutorials</a>
					</li>
					
						
					<li class="item item-nav">
						<a href="/course.html">Course</a>
					</li>
					
						
					<li class="item item-nav">
						<a href="/team.html">Team</a>
					</li>
					
						
					<li class="item item-nav">
						<a href="/involve.html">Get involved</a>
					</li>
					
						
					<li class="item item-nav">
						<a href="/links.html">Links</a>
					</li>
					
						
					<li class="item item-nav">
						<a href="/contact.html">Contact</a>
					</li>
					
				</ul>
			</nav>
		</div>
	</div>
</header>

			<div class="block">
  <center><img src="/img/tutheader_iris.png" alt="Img"></center>
</div>

<p><em>Material for this tutorial was adapted from the <a href="https://scitools.org.uk" target="_blank" rel="noopener noreferrer">SciTools</a> tutorial (SciTools is the group that maintain the Iris software.) It was adapted and modified under the GNU public licence v 3.0 for this OurCodingClub tutorial and we acknowledge appreciate the use of original source materials from SciTools - Thank you!</em></p>

<p>Welcome to this tutorial in the Python series about the Iris python package. Iris is a powerful tool used for manipulating multi-dimensional earth science data. Iris is really useful when you are dealing with data from sources such as weather and climate models, particularly when it is stored in common formats such as NetCDF (a common data file format used in the climate science community.)</p>

<p>Iris has data manipulation and visualisation features such as:</p>

<h5 id="--a-visualisation-interface-based-on-matplotlib-and-cartopy">- A visualisation interface based on matplotlib and cartopy</h5>
<h5 id="--unit-conversion">- Unit conversion</h5>
<h5 id="--subsetting-and-extraction-of-data">- Subsetting and extraction of data</h5>
<h5 id="--merge-and-concatenate">- Merge and concatenate</h5>
<h5 id="--aggregations-and-reductions-including-min-max-mean-and-weighted-averages">- Aggregations and reductions (including min, max, mean and weighted averages)</h5>
<h5 id="--interpolation-and-regridding-including-nearest-neighbor-linear-and-area-weighted">- Interpolation and regridding (including nearest-neighbor, linear and area-weighted)</h5>

<p>If you need any of the above features and you find that you are <strong>regularly writing your own custom functions in Python to do these things</strong>, you may find that Iris already has these features availabe, and it can save you a lot of time in your work.</p>

<h3 id="tutorial-aims">Tutorial aims:</h3>

<h4 id="1-understand-what-iris-is"><a href="#understanding">1. Understand what Iris is</a></h4>

<h4 id="2-learn-about-the-core-iris-data-structure-the-iris-cube"><a href="#cube">2. Learn about the core Iris data structure: the Iris cube</a></h4>

<h4 id="3-learn-how-to-load-data-selectively-from-large-datasets"><a href="#loading">3. Learn how to load data selectively from large datasets</a></h4>

<h4 id="4-learn-how-to-manipulate-and-plot-data-with-iris"><a href="#plotting">4. Learn how to manipulate and plot data with iris</a></h4>

<p><a name="understanding"></a></p>

<h2 id="what-is-iris">What is Iris?</h2>

<p>Iris was developed originally by the Met Office (UK) out of a need for dealing with the many file formats used in the weather, climate, and ocean sciences scientific community. Many users of Iris had previously had to write their own code from scratch to handle and manipulate these file-formats, such as NetCDF, GRIB, and other common (and not-so-common) formats, alternatively they had to use one of the many separately available packages for each type of file format. (Such as <code class="language-plaintext highlighter-rouge">python-netcdf4</code> for python, etc.). This resulted in a lot of duplicated effort from researchers re-writing what was effectively the same or very similar code. In addition, many operations on weather and climate data are essentially very similar, such as converting between different units, extracting subsets of the data, merging datasets, interpolating data, and so on. Iris was developed to bring together these operations and provide a file-format agnostic package to deal with these commonly used operations.</p>

<p>Iris operates around a central data structure used to store multi-dimiensional data when you are working on it called a <code class="language-plaintext highlighter-rouge">cube</code>. This typically represents gridded data that has many levels as well as x and y dimensions (Though Iris is still useful for 2 dimesnional data as well.)</p>

<p>The third dimension in an Iris could be model levels, different heights in the atmosphere, or depths in the ocean. It could also be used to represent different time-slices in a model run. In short, the Iris cube data structure is very flexible and can be used to represent a large variety of different datasets.</p>

<p>We are going to have a look at how the Iris <code class="language-plaintext highlighter-rouge">cube</code> data structure works now, but first, let’s test that we have iris installed:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">iris</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">print</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
</code></pre></div></div>

<p>This should print out the version numbers of <code class="language-plaintext highlighter-rouge">iris</code> and <code class="language-plaintext highlighter-rouge">numpy</code>, the two main requirements for this tutorial.</p>

<p>If you do not have these two packages installed, see this guide on <a href="https://scitools.org.uk/iris/docs/latest/installing.html" target="_blank" rel="noopener noreferrer">installing iris</a>. (We assume you already have Python installed in your computing environmnet.</p>

<p><a name="cube"></a></p>

<h2 id="the-iris-cube">The Iris Cube</h2>

<p><strong>Learning outcome</strong>: by the end of this section, you will be able to explain the capabilities and functionality of Iris cubes and coordinates.</p>

<p>The top level object in Iris is called a cube. A cube contains data and metadata about a single phenomenon and is an implementation of the data model interpreted from the <em>Climate and Forecast (CF) Metadata Conventions</em>.</p>

<p>Each cube has:</p>

<h5 id="--a-data-array-typically-a-numpy-array">- A data array (typically a NumPy array).</h5>
<h5 id="--a-name-preferably-a-cf-standard-name-to-describe-the-phenomenon-that-the-cube-represents">- A “name”, preferably a CF “standard name” to describe the phenomenon that the cube represents.</h5>
<h5 id="--a-collection-of-coordinates-to-describe-each-of-the-dimensions-of-the-data-array-these-coordinates-are-split-into-two-types">- A collection of coordinates to describe each of the dimensions of the data array. These coordinates are split into two types:</h5>
<h6 id="--dimensioned-coordinates-are-numeric-monotonic-and-represent-a-single-dimension-of-the-data-array-there-may-be-only-one-dimensioned-coordinate-per-data-dimension">- Dimensioned coordinates are numeric, monotonic and represent a single dimension of the data array. There may be only one dimensioned coordinate per data dimension.</h6>
<h6 id="--auxilliary-coordinates-can-be-of-any-type-including-discrete-values-such-as-strings-and-may-represent-more-than-one-data-dimension">- Auxilliary coordinates can be of any type, including discrete values such as strings, and may represent more than one data dimension.</h6>

<p>A fuller explanation is available in the <a href="http://scitools.org.uk/iris/docs/latest/userguide/iris_cubes.html" target="_blank" rel="noopener noreferrer">Iris User Guide</a>.</p>

<p>Let’s take a simple example to demonstrate the cube concept.</p>

<p>Suppose we have a <code class="language-plaintext highlighter-rouge">(3, 2, 4)</code> NumPy array:</p>

<center> <img src="/img/iris_multi_array.png" alt="Img" style="width: 500px;"> </center>

<p>Where dimensions 0, 1, and 2 have lengths 3, 2 and 4 respectively.</p>

<p>The Iris cube to represent this data may consist of:</p>

<h5 id="--a-standard-name-of-air_temperature-and-units-of-kelvin">- a standard name of “air_temperature” and units of “kelvin”</h5>

<h5 id="--a-data-array-of-shape-3-2-4">- a data array of shape <code class="language-plaintext highlighter-rouge">(3, 2, 4)</code>
</h5>

<h5 id="--a-coordinate-mapping-to-dimension-0-consisting-of">- a coordinate, mapping to dimension 0, consisting of:</h5>
<h6 id="--a-standard-name-of-height-and-units-of-meters">- a standard name of “height” and units of “meters”</h6>
<h6 id="--an-array-of-length-3-representing-the-3-height-points">- an array of length 3 representing the 3 height points</h6>

<h5 id="--a-coordinate-mapping-to-dimension-1-consisting-of">- a coordinate, mapping to dimension 1, consisting of:</h5>
<h6 id="--a-standard-name-of-latitude-and-units-of-degrees">- a standard name of “latitude” and units of “degrees”</h6>
<h6 id="--an-array-of-length-2-representing-the-2-latitude-points">- an array of length 2 representing the 2 latitude points</h6>
<h6 id="--a-coordinate-system-such-that-the-latitude-points-could-be-fully-located-on-the-globe">- a coordinate system such that the latitude points could be fully located on the globe</h6>

<h5 id="--a-coordinate-mapping-to-dimension-2-consisting-of">- a coordinate, mapping to dimension 2, consisting of:</h5>
<h6 id="--a-standard-name-of-longitude-and-units-of-degrees">- a standard name of “longitude” and units of “degrees”</h6>
<h6 id="--an-array-of-length-4-representing-the-4-longitude-points">- an array of length 4 representing the 4 longitude points</h6>
<h6 id="--a-coordinate-system-such-that-the-longitude-points-could-be-fully-located-on-the-globe">- a coordinate system such that the longitude points could be fully located on the globe</h6>

<p>Pictorially the cube has taken on more information than a simple array:</p>

<center> <img src="/img/iris_multi_array_to_cube.png" alt="Img" style="width: 500px;"> </center>

<h3 id="working-with-a-cube">Working with a cube</h3>

<p>Whilst it is possible to construct a cube by hand, a far more common approach to getting hold of a cube is to use the Iris load function to access data that already exists in a file.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'uk_hires.pp'</span><span class="p">)</span>
<span class="n">cubes</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cubes</span><span class="p">)</span>
</code></pre></div></div>

<p>We can see that we’ve loaded two cubes, one representing the “surface_altitude” and the other representing “air_potential_temperature”. We can infer even more detail from this printout; for example, what are the dimensions and shape of the “air_potential_temperature” cube?</p>

<p>Above we’ve printed the <code class="language-plaintext highlighter-rouge">iris.cube.CubeList</code> instance representing all of the cubes found in the given filename. However, we can see more detail by printing individual cubes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'uk_hires.pp'</span><span class="p">)</span>
<span class="n">cubes</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

<span class="n">air_pot_temp</span> <span class="o">=</span> <span class="n">cubes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">air_pot_temp</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="cube-attributes">Cube attributes</h3>

<p>We can create a single cube from the <code class="language-plaintext highlighter-rouge">load_cube</code> command. Iris also provides some sample data that we can work with in the <code class="language-plaintext highlighter-rouge">iris.sample_data_path</code> function. Printing a cube object in Python will give you an overview of the data it contains and the layout of that data:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'A1B_north_america.nc'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
</code></pre></div></div>
<p>Which should print:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_temperature / (K)               (time: 240; latitude: 37; longitude: 49)
     Dimension coordinates:
          time                           x              -              -
          latitude                       -              x              -
          longitude                      -              -              x
     Auxiliary coordinates:
          forecast_period                x              -              -
     Scalar coordinates:
          forecast_reference_time: 1859-09-01 06:00:00
          height: 1.5 m
     Attributes:
          Conventions: CF-1.5
          Model scenario: A1B
          STASH: m01s03i236
          source: Data from Met Office Unified Model 6.05
     Cell methods:
          mean: time (6 hour)
</code></pre></div></div>

<p>To access a cube’s data array the <code class="language-plaintext highlighter-rouge">data</code> property exists. This is either a NumPy array or in some cases a NumPy masked array. It is very important to note that for most of the supported filetypes in Iris, the cube’s data isn’t actually loaded until you request it via this property (either directly or indirectly). After you<code class="language-plaintext highlighter-rouge">ve accessed the data once, it is stored on the cube and thus won</code>t be loaded from disk again.</p>

<p>To find the shape of a cube’s data it is possible to call <code class="language-plaintext highlighter-rouge">cube.data.shape</code> or <code class="language-plaintext highlighter-rouge">cube.data.ndim</code>, but this will trigger any unloaded data to be loaded. Therefore <code class="language-plaintext highlighter-rouge">shape</code> and <code class="language-plaintext highlighter-rouge">ndim</code> are properties available directly on the cube that do not unnecessarily load data.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'A1B_north_america.nc'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</code></pre></div></div>

<p>Which should display:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(240, 37, 49)
3
&lt;class 'numpy.ma.core.MaskedArray'&gt;
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">standard_name</code>, <code class="language-plaintext highlighter-rouge">long_name</code> and to an extent <code class="language-plaintext highlighter-rouge">var_name</code> are all attributes to describe the phenomenon that the cube represents. The <code class="language-plaintext highlighter-rouge">name()</code> method is a convenience that looks at the name attributes in the order they are listed above, returning the first non-empty string. To rename a cube, it is possible to set the attributes manually, but it is generally easier to use the <code class="language-plaintext highlighter-rouge">rename()</code> method.</p>

<p><em>From now on, we are not going to re-type the <code class="language-plaintext highlighter-rouge">cube = iris.load_cube(...)</code> line, it is assumed you will just change or append the lines below to your existing Python code. This is done to avoid having to reload the data into memory in each example!</em></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">standard_name</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">long_name</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">var_name</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

</code></pre></div></div>

<p>Check that you get the output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_temperature
None
air_temperature
air_temperature
</code></pre></div></div>

<p>There are a set of conventions used in climate data files called the “CF-conventions”. These are standard names and units that are used to make interchanging and sharing data more consistent and straightforward. More about the CF-conventions can be read here: XXXX</p>

<p>Iris can deal with CF-convention formatted data, but it also supports non-CF named data too. To illustrate this, we can change the name of our cube (in other words, rename our dataset) and see how Iris deals with this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cube</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">"A name that isn't a valid CF standard name"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">standard_name</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">long_name</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">var_name</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
</code></pre></div></div>

<p>Should print:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>None
A name that isn't a valid CF standard name
None
A name that isn't a valid CF standard name
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">units</code> attribute on a cube tells us the units of the numbers held in the data array. We can manually change the units, or better, we can convert the cube to another unit using the <code class="language-plaintext highlighter-rouge">convert_units</code> method, which will automatically update the data array.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="nb">max</span><span class="p">())</span>
<span class="n">cube</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="s">'Celsius'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="nb">max</span><span class="p">())</span>
</code></pre></div></div>

<p>Should give you:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>K
306.0733
Celsius
32.9233
</code></pre></div></div>

<p>A cube has a dictionary for extra general purpose attributes, which can be accessed with the <code class="language-plaintext highlighter-rouge">cube.attributes</code> attribute:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s">'STASH'</span><span class="p">])</span>
</code></pre></div></div>

<p>Prints:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{'Conventions': 'CF-1.5', 'STASH': STASH(model=1, section=3, item=236), 'Model scenario': 'A1B', 'source': 'Data from Met Office Unified Model 6.05'}
m01s03i236
</code></pre></div></div>

<h3 id="coordinates">Coordinates</h3>

<p>As we’ve seen, cubes need coordinate information to help us describe the underlying phenomenon. Typically a cube’s coordinates are accessed with the <code class="language-plaintext highlighter-rouge">coords</code> or <code class="language-plaintext highlighter-rouge">coord</code> methods. The latter <em>must</em> return exactly one coordinate for the given parameter filters, where the former returns a list of matching coordinates, possibly of length 0.</p>

<p>For example, to access the time coordinate, and print the first 4 times:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">time</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s">'time'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<p>Will display a representation of the time coordinate, as well as the metadata associated with it. This will be formatted according to the time units specified, if there are any present:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DimCoord([1860-06-01 00:00:00, 1861-06-01 00:00:00, 1862-06-01 00:00:00,
       1863-06-01 00:00:00], bounds=[[1859-12-01 00:00:00, 1860-12-01 00:00:00],
       [1860-12-01 00:00:00, 1861-12-01 00:00:00],
       [1861-12-01 00:00:00, 1862-12-01 00:00:00],
       [1862-12-01 00:00:00, 1863-12-01 00:00:00]], standard_name='time', calendar='360_day', var_name='time')
</code></pre></div></div>

<p>The coordinate interface is very similar to that of a cube. The attributes that exist on both cubes and coordinates are: <code class="language-plaintext highlighter-rouge">standard_name</code>, <code class="language-plaintext highlighter-rouge">long_name</code>, <code class="language-plaintext highlighter-rouge">var_name</code>, <code class="language-plaintext highlighter-rouge">units</code>,<code class="language-plaintext highlighter-rouge">attributes</code> and <code class="language-plaintext highlighter-rouge">shape</code>. Similarly, the <code class="language-plaintext highlighter-rouge">name()</code>, <code class="language-plaintext highlighter-rouge">rename()</code> and <code class="language-plaintext highlighter-rouge">convert_units()</code> methods also exist on a coordinate.</p>

<p>A coordinate does not have <code class="language-plaintext highlighter-rouge">data</code>, instead it has <code class="language-plaintext highlighter-rouge">points</code> and <code class="language-plaintext highlighter-rouge">bounds</code> (<code class="language-plaintext highlighter-rouge">bounds</code> may be <code class="language-plaintext highlighter-rouge">None</code>). In Iris, time coordinates are currently represented as “a number since an epoch”. So for example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">units</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">points</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<p>Will show the time values as whole numbers, rather than formatting them as a more human readable time-date value:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unit('hours since 1970-01-01 00:00:00', calendar='360_day')
[-946800. -938160. -929520. -920880.]
[[-951120. -942480.]
 [-942480. -933840.]
 [-933840. -925200.]
 [-925200. -916560.]]
</code></pre></div></div>

<p>These numbers can be converted to datetime objects with the unit’s <code class="language-plaintext highlighter-rouge">num2date</code> method. Dates can be converted back again with the <code class="language-plaintext highlighter-rouge">date2num</code> method:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">points</span><span class="p">[:</span><span class="mi">4</span><span class="p">]))</span>
<span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre></div></div>

<p>Giving:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[cftime.Datetime360Day(1860, 6, 1, 0, 0, 0, 0, 4, 151)
 cftime.Datetime360Day(1861, 6, 1, 0, 0, 0, 0, 0, 151)
 cftime.Datetime360Day(1862, 6, 1, 0, 0, 0, 0, 3, 151)
 cftime.Datetime360Day(1863, 6, 1, 0, 0, 0, 0, 6, 151)]
720.0
</code></pre></div></div>

<p>Another important attribute on a coordinate is its coordinate system. Coordinate systems may be <code class="language-plaintext highlighter-rouge">None</code> for trivial coordinates, but particularly for spatial coordinates, they may be complex definitions of things such as the projection, ellipse and/or datum.</p>

<p>We can retrieve information about our coordinate system for example, by examining the latitude variable. The coordinate system is an attribute that can be printed, like so:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lat</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s">'latitude'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">coord_system</span><span class="p">)</span>
</code></pre></div></div>

<p>Showing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GeogCS(6371229.0)

</code></pre></div></div>

<p><a name="loading"></a></p>

<h2 id="loading-and-saving-data">Loading and saving data</h2>

<p><strong>Learning outcome</strong>: by the end of this section, you will be able to use Iris to load datasets from disk as Iris cubes and save Iris cubes back to disk.</p>

<p>Loading and savingdata is one aspect where Iris really shines over standard numpy or pandas methods of loading climate data. Notice that in the above examples we didn’t have to specify anything about the file formats of the netCDF files that we used.</p>

<h3 id="iris-load-functions">Iris load functions</h3>

<p>There are three main load functions in Iris: <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">load_cube</code> and <code class="language-plaintext highlighter-rouge">load_cubes</code>.</p>

<ol>
  <li>
<strong>load</strong> is a general purpose loading function. Typically this is where all data analysis will start, before more loading is refined with the more controlled loading from the other two functions.</li>
  <li>
<strong>load_cube</strong> returns a single cube from the given source(s) and constraint. There will be exactly one cube, or an exception will be raised.</li>
  <li>
<strong>load_cubes</strong> returns a list of cubes from the given sources(s) and constraint(s). There will be exactly one cube per constraint, or an exception will be raised.</li>
</ol>

<p>Note: <code class="language-plaintext highlighter-rouge">load_cube</code> is a special case of <code class="language-plaintext highlighter-rouge">load</code>, which can be seen with:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'air_temp.pp'</span><span class="p">)</span>
<span class="n">c1</span><span class="p">,</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>    <span class="c1"># True
</span></code></pre></div></div>

<p>In other words, <code class="language-plaintext highlighter-rouge">iris.load()</code> has figured out that our sample dataset contains a single variable, and so returns a single cube, just like <code class="language-plaintext highlighter-rouge">load_cube</code> would do as well.</p>

<h3 id="saving-cubes">Saving cubes</h3>

<p>The <code class="language-plaintext highlighter-rouge">iris.save</code> function provides a convenient interface to save Cube and CubeList instances.</p>

<p>To save some cubes to a NetCDF file:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'uk_hires.pp'</span><span class="p">)</span>
<span class="n">cubes</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="n">iris</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cubes</span><span class="p">,</span> <span class="s">'saved_cubes.nc'</span><span class="p">)</span>
</code></pre></div></div>

<p>We are just loading the netcdf file, converting it to the general purpose Iris cube data structure, and then saving it back to dsik. Iris takes care of converting the format, and the format is automatically taken care of.</p>

<p><em>You can skip this section if you are less familiar with the command line netCDF tools</em></p>

<p>To inspect our new netcdf file, we can check it with <code class="language-plaintext highlighter-rouge">ncdump</code> - the utility installed for inspecting netcdf files. (This should already be installed if you are on one of the Edinburgh linux servers. Type the following at the linux command line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ncdump -h saved_cubes.nc | head -n 20
</code></pre></div></div>
<p>Which should output something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
netcdf saved_cubes {
dimensions:
	time = 3 ;
	model_level_number = 7 ;
	grid_latitude = 204 ;
	grid_longitude = 187 ;
	bnds = 2 ;
variables:
	float air_potential_temperature(time, model_level_number, grid_latitude, grid_longitude) ;
		air_potential_temperature:standard_name = "air_potential_temperature" ;
		air_potential_temperature:units = "K" ;
		air_potential_temperature:um_stash_source = "m01s00i004" ;
		air_potential_temperature:grid_mapping = "rotated_latitude_longitude" ;
		air_potential_temperature:coordinates = "forecast_period forecast_reference_time level_height sigma surface_altitude" ;
	int rotated_latitude_longitude ;
		rotated_latitude_longitude:grid_mapping_name = "rotated_latitude_longitude" ;
		rotated_latitude_longitude:longitude_of_prime_meridian = 0. ;
		rotated_latitude_longitude:earth_radius = 6371229. ;
		rotated_latitude_longitude:grid_north_pole_latitude = 37.5 ;
		rotated_latitude_longitude:grid_north_pole_longitude = 177.5 ;
}
</code></pre></div></div>

<h3 id="out-of-core-processing">Out-of-core Processing</h3>

<p><a href="https://en.wikipedia.org/wiki/External_memory_algorithm" target="_blank" rel="noopener noreferrer">Out-of-core processing</a> is a technical term that describes being able to process datasets that are too large to fit in memory at once. In Iris, this functionality is referred to as <strong>lazy data</strong>. It means that you can use Iris to load, process and save datasets that are too large to fit in memory without running out of memory. This is achieved by loading only the dataset`s metadata and not the data array, unless this is specifically requested.</p>

<p>To determine whether your cube has lazy data:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'air_temp.pp'</span><span class="p">)</span>
<span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">())</span>
</code></pre></div></div>

<p>Iris tries to maintain lazy data as much as possible. We refer to the operation of loading a cube`s lazy data as ‘realising’ the cube’s data. A cube’s lazy data will only be loaded in a limited number of cases, including:</p>

<h5 id="--when-the-user-directly-requests-the-cubes-data-using-cubedata">- When the user directly requests the cube’s data using <code class="language-plaintext highlighter-rouge">cube.data</code>,</h5>
<h5 id="--when-there-is-no-lazy-data-processing-algorithm-available-to-perform-the-requested-data-processing-such-as-for-peak-finding-and">- When there is no lazy data processing algorithm available to perform the requested data processing, such as for peak finding, and</h5>
<h5 id="--where-actual-data-values-are-necessary-such-as-for-cube-plotting">- Where actual data values are necessary, such as for cube plotting.</h5>

<h2 id="cube-control-and-subsetting">Cube control and subsetting</h2>

<p><strong>Learning outcome</strong>: by the end of this section, you will be able to apply Iris functionality to take a useful subset of an Iris cube and to combine multiple Iris cubes into a new larger cube.</p>

<h3 id="constraints-and-extract">Constraints and Extract</h3>

<p>We’ve already seen the basic <code class="language-plaintext highlighter-rouge">load</code> function, but we can also control which cubes are actually loaded with <em>constraints</em>. The simplest constraint is just a string, which filters cubes based on their name:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'uk_hires.pp'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">'air_potential_temperature'</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: air_potential_temperature / (K)     (time: 3; model_level_number: 7; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>Iris’s constraints mechanism provides a powerful way to filter a subset of data from a larger collection. We’ve already seen that constraints can be used at load time to return data of interest from a file, but we can also apply constraints to a single cube, or a list of cubes, using their respective <code class="language-plaintext highlighter-rouge">extract</code> methods:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cubes</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cubes</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s">'air_potential_temperature'</span><span class="p">))</span>
</code></pre></div></div>

<p>Which will give us the same output as the previous output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: air_potential_temperature / (K)     (time: 3; model_level_number: 7; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>The simplest constraint, namely a string that matches a cube’s name, is conveniently converted into an actual <code class="language-plaintext highlighter-rouge">iris.Constraint</code> instance wherever needed. However, we could construct this constraint manually and compare with the previous result:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pot_temperature_constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="s">'air_potential_temperature'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cubes</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pot_temperature_constraint</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: air_potential_temperature / (K)     (time: 3; model_level_number: 7; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>The Constraint constructor also takes arbitrary keywords to constrain coordinate values. For example, to extract model level number 10 from the air potential temperature cube:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pot_temperature_constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="s">'air_potential_temperature'</span><span class="p">,</span>
                                             <span class="n">model_level_number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cubes</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pot_temperature_constraint</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>We can pass a list of possible values, and even combine two constraints with <code class="language-plaintext highlighter-rouge">&amp;</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">cubes</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s">'air_potential_temperature'</span> <span class="o">&amp;</span> 
                    <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">model_level_number</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">])))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: air_potential_temperature / (K)     (time: 3; model_level_number: 2; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>We can define arbitrary functions that operate on each cell of a coordinate. This is a common thing to do for floating point coordinates, where exact equality is non-trivial.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">less_than_10</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
    <span class="s">"""Return True for values that are less than 10."""</span>
    <span class="k">return</span> <span class="n">cell</span> <span class="o">&lt;</span> <span class="mi">10</span>

<span class="k">print</span><span class="p">(</span><span class="n">cubes</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="s">'air_potential_temperature'</span><span class="p">,</span>
                                    <span class="n">model_level_number</span><span class="o">=</span><span class="n">less_than_10</span><span class="p">)))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: air_potential_temperature / (K)     (time: 3; model_level_number: 3; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<h3 id="time-constraints">Time Constraints</h3>

<p>It is common to want to build a constraint for time. This can be achieved by comparing cells containing datetimes.There are a few different approaches for producing time constraints in Iris. We will focus here on one approach for constraining on time in Iris.</p>

<p>This approach allows us to access individual components of cell datetime objects and run comparisons on those:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">time_constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="n">cell</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">11</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">air_pot_temp</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">time_constraint</span><span class="p">)</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="bp">True</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_potential_temperature / (K)     (model_level_number: 7; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<h3 id="indexing">Indexing</h3>

<p>Cubes can be indexed in a familiar manner to that of NumPy arrays:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'uk_hires.pp'</span><span class="p">)</span>
<span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">'air_potential_temperature'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_potential_temperature / (K)     (time: 3; model_level_number: 7; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>We can define a constraint on our cube by creating a list of indices to be used, similarly to NumPy:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subcube</span> <span class="o">=</span> <span class="n">cube</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span><span class="mi">35</span><span class="p">,</span> <span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="n">subcube</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'air_potential_temperature / (K)     (time: 3; model_level_number: 4; grid_latitude: 20; grid_longitude: 10)'
</code></pre></div></div>

<p><strong>Note: the result of indexing a cube is <em>always</em> a copy and never a <em>view</em> on the original data.</strong></p>

<h3 id="iteration">Iteration</h3>

<p>We can loop through all desired subcubes in a larger cube using the cube methods <code class="language-plaintext highlighter-rouge">slices</code> and <code class="language-plaintext highlighter-rouge">slices_over</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'uk_hires.pp'</span><span class="p">)</span>
<span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span>
                      <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="s">'air_potential_temperature'</span><span class="p">,</span>
                                      <span class="n">model_level_number</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="bp">True</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>The <strong><code class="language-plaintext highlighter-rouge">slices</code></strong> method returns all the slices of a cube on the dimensions specified by the coordinates passed to the slices method.</p>

<p>So in this example, each <code class="language-plaintext highlighter-rouge">grid_latitude</code> / <code class="language-plaintext highlighter-rouge">grid_longitude</code> slice of the cube is returned:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">subcube</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">slices</span><span class="p">([</span><span class="s">'grid_latitude'</span><span class="p">,</span> <span class="s">'grid_longitude'</span><span class="p">]):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">subcube</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_potential_temperature / (K)     (grid_latitude: 204; grid_longitude: 187)
air_potential_temperature / (K)     (grid_latitude: 204; grid_longitude: 187)
air_potential_temperature / (K)     (grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>We can use <strong><code class="language-plaintext highlighter-rouge">slices_over</code></strong> to return one subcube for each coordinate value in a specified coordinate. This helps us when trying to retrieve all the slices along a given cube dimension.</p>

<p>For example, let’s consider retrieving all the slices over the time dimension (i.e. each time step in its own cube with a scalar time coordinate) using ``slices<code class="language-plaintext highlighter-rouge">. As per the above example, to achieve this using </code>slices` we would have to specify all the cube’s dimensions <em>except</em> the time dimension.</p>

<p>Let’s take a look at <code class="language-plaintext highlighter-rouge">slices_over</code> providing this functionality:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'uk_hires.pp'</span><span class="p">)</span>
<span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">'air_potential_temperature'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">subcube</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s">'model_level_number'</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">subcube</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<h3 id="discussion-indexing-and-slicing">Discussion: Indexing and slicing</h3>

<h5 id="--what-are-the-similarities-between-indexing-and-slicing">- What are the similarities between indexing and slicing?</h5>
<h5 id="--what-are-the-differences">- What are the differences?</h5>
<h5 id="--which-cube-slicing-method-would-be-easiest-to-use-to-return-all-subcubes-along-the-realization-dimension">- Which cube slicing method would be easiest to use to return all subcubes along the realization dimension?</h5>
<h5 id="--which-cube-slicing-method-would-be-easiest-to-use-to-return-all-horizontal-2d-slices-in-a-4d-cube">- Which cube slicing method would be easiest to use to return all horizontal 2D slices in a 4D cube?</h5>
<h5 id="--in-what-situations-would-indexing-be-the-best-way-to-subset-a-cube-what-about-slicing">- In what situations would indexing be the best way to subset a cube? What about slicing?</h5>

<p><a name="plotting"></a></p>

<h2 id="data-processing-and-visualisation">Data Processing and Visualisation</h2>

<p><strong>Learning outcome</strong>: by the end of this section, you will be able to use Iris to analyse and visualise weather and climate datasets.</p>

<h3 id="plotting">Plotting</h3>

<p>Iris comes with two plotting modules called <code class="language-plaintext highlighter-rouge">iris.plot</code> and <code class="language-plaintext highlighter-rouge">iris.quickplot</code> that wrap some of the common matplotlib plotting functions such that cubes can be passed as input rather than the usual NumPy arrays. The two modules are very similar, with the primary difference being that <code class="language-plaintext highlighter-rouge">quickplot</code> will add extra information to the axes, such as:</p>

<h5 id="--a-colorbar">- a colorbar,</h5>
<h5 id="--labels-for-the-x-and-y-axes-and">- labels for the x and y axes, and</h5>
<h5 id="--a-title-where-possible">- a title where possible.</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">iris.plot</span> <span class="k">as</span> <span class="n">iplt</span>
<span class="kn">import</span> <span class="nn">iris.quickplot</span> <span class="k">as</span> <span class="n">qplt</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'A1B_north_america.nc'</span><span class="p">))</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">cube</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
</code></pre></div></div>

<p>Will print out the following summary of the sliced cube:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_temperature / (K)               (longitude: 49)
     Dimension coordinates:
          longitude                           x
     Scalar coordinates:
          forecast_period: 2075754 hours
          forecast_reference_time: 1859-09-01 06:00:00
          height: 1.5 m
          latitude: 40.0 degrees
          time: 2099-06-01 00:00:00, bound=(2098-12-01 00:00:00, 2099-12-01 00:00:00)
     Attributes:
          Conventions: CF-1.5
          Model scenario: A1B
          STASH: m01s03i236
          source: Data from Met Office Unified Model 6.05
     Cell methods:
          mean: time (6 hour)
</code></pre></div></div>

<p>Now we can do some plotting! Adding to the above script, we can write:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iplt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p>For comparison, lets plot the result of <code class="language-plaintext highlighter-rouge">iplt.plot</code> next to <code class="language-plaintext highlighter-rouge">qplt.plot</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">iplt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">qplt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p>Notice how the result of qplt has axis labels and a title; everything else about the axes is identical.</p>

<p>The plotting functions in Iris have strict rules on the dimensionality of the inputted cubes. For example, a 2d cube is needed in order to create a contour plot:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">qplt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">cube</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="maps-with-cartopy">Maps with cartopy</h3>

<p>When the result of a plot operation is a map, Iris will automatically create an appropriate cartopy axes if one doesn’t already exist.</p>

<p>We can use matplotlib’s <code class="language-plaintext highlighter-rouge">gca()</code> function to get hold of the automatically created cartopy axes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">cartopy.crs</span> <span class="k">as</span> <span class="n">ccrs</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">qplt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">cube</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">coastlines</span><span class="p">()</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">RotatedPole</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">37</span><span class="p">))</span>
<span class="n">qplt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">cube</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">coastlines</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="cube-maths">Cube maths</h3>

<p>Basic mathematical operators exist on the cube to allow one to add, subtract, divide, multiply and perform other mathematical operations on cubes of a similar shape to one another:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a1b</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'A1B_north_america.nc'</span><span class="p">))</span>
<span class="n">e1</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'E1_north_america.nc'</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="bp">True</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">a1b</span><span class="p">)</span>
</code></pre></div></div>

<p>Should show us the summary:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_temperature / (K)               (time: 240; latitude: 37; longitude: 49)
air_temperature / (K)               (time: 240; latitude: 37; longitude: 49)
     Dimension coordinates:
          time                           x              -              -
          latitude                       -              x              -
          longitude                      -              -              x
     Auxiliary coordinates:
          forecast_period                x              -              -
     Scalar coordinates:
          forecast_reference_time: 1859-09-01 06:00:00
          height: 1.5 m
     Attributes:
          Conventions: CF-1.5
          Model scenario: A1B
          STASH: m01s03i236
          source: Data from Met Office Unified Model 6.05
     Cell methods:
          mean: time (6 hour)
</code></pre></div></div>

<p>To find the difference between these two cubes we have created, we can do this by adding the following lines of code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scenario_difference</span> <span class="o">=</span> <span class="n">a1b</span> <span class="o">-</span> <span class="n">e1</span>
<span class="k">print</span><span class="p">(</span><span class="n">scenario_difference</span><span class="p">)</span>
</code></pre></div></div>

<p>Giving us:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unknown / (K)                       (time: 240; latitude: 37; longitude: 49)
     Dimension coordinates:
          time                           x              -              -
          latitude                       -              x              -
          longitude                      -              -              x
     Auxiliary coordinates:
          forecast_period                x              -              -
     Scalar coordinates:
          forecast_reference_time: 1859-09-01 06:00:00
          height: 1.5 m
</code></pre></div></div>

<p>Notice that the resultant cube’s name is now <code class="language-plaintext highlighter-rouge">unknown</code> and that resultant cube’s <code class="language-plaintext highlighter-rouge">attributes</code> and <code class="language-plaintext highlighter-rouge">cell_methods</code> have disappeared; this is because these all differed between the two input cubes.</p>

<p>It is also possible to operate on cubes with numeric scalars, NumPy arrays and even cube coordinates:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">e1</span> <span class="o">*</span> <span class="n">e1</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s">'latitude'</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unknown / (0.0174532925199433 K.rad) (time: 240; latitude: 37; longitude: 49)
     Dimension coordinates:
          time                            x              -              -
          latitude                        -              x              -
          longitude                       -              -              x
     Auxiliary coordinates:
          forecast_period                 x              -              -
     Scalar coordinates:
          forecast_reference_time: 1859-09-01 06:00:00
          height: 1.5 m
</code></pre></div></div>

<p>Cube broadcasting is also taking place, meaning that the two inputs (cube, coordinate, array, or even constant value) don’t need to have the same shape:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="mf">5.0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unknown / (K)                       (time: 240; latitude: 37; longitude: 49)
     Dimension coordinates:
          time                           x              -              -
          latitude                       -              x              -
          longitude                      -              -              x
     Auxiliary coordinates:
          forecast_period                x              -              -
     Scalar coordinates:
          forecast_reference_time: 1859-09-01 06:00:00
          height: 1.5 m
</code></pre></div></div>

<p>As we`ve just seen, we have the ability to update the cube’s data directly. Whenever we do this though, we should be mindful of updating appropriate metadata on the cube:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">e1_hot</span> <span class="o">=</span> <span class="n">e1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">e1_hot</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less_equal</span><span class="p">(</span><span class="n">e1_hot</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">280</span><span class="p">)</span>
<span class="n">e1_hot</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">'air temperatures greater than 280K'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">e1_hot</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air temperatures greater than 280K / (K) (time: 240; latitude: 37; longitude: 49)
     Dimension coordinates:
          time                                x              -              -
          latitude                            -              x              -
          longitude                           -              -              x
     Auxiliary coordinates:
          forecast_period                     x              -              -
     Scalar coordinates:
          forecast_reference_time: 1859-09-01 06:00:00
          height: 1.5 m
     Attributes:
          Conventions: CF-1.5
          Model scenario: E1
          STASH: m01s03i236
          source: Data from Met Office Unified Model 6.05
     Cell methods:
          mean: time (6 hour)
</code></pre></div></div>

<h3 id="cube-aggregation-and-statistics">Cube aggregation and statistics</h3>

<p>Many standard univariate aggregations exist in Iris. Aggregations allow one or more dimensions of a cube to be statistically collapsed for the purposes of statistical analysis of the cube’s data. Iris uses the term “aggregators” to refer to the statistical operations that can be used for aggregation.</p>

<p>A list of aggregators is available at http://scitools.org.uk/iris/docs/latest/iris/iris/analysis.html.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fname</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s">'uk_hires.pp'</span><span class="p">)</span>
<span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">'air_potential_temperature'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="bp">True</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_potential_temperature / (K)     (time: 3; model_level_number: 7; grid_latitude: 204; grid_longitude: 187)
</code></pre></div></div>

<p>To take the vertical mean of this cube:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s">'model_level_number'</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>air_potential_temperature / (K)     (time: 3; grid_latitude: 204; grid_longitude: 187)
     Dimension coordinates:
          time                           x                 -                    -
          grid_latitude                  -                 x                    -
          grid_longitude                 -                 -                    x
     Auxiliary coordinates:
          forecast_period                x                 -                    -
          surface_altitude               -                 x                    x
     Derived coordinates:
          altitude                       -                 x                    x
     Scalar coordinates:
          forecast_reference_time: 2009-11-19 04:00:00
          level_height: 696.6666 m, bound=(0.0, 1393.3333) m
          model_level_number: 10, bound=(1, 19)
          sigma: 0.92292976, bound=(0.8458596, 1.0)
     Attributes:
          STASH: m01s00i004
          source: Data from Met Office Unified Model
          um_version: 7.3
     Cell methods:
          mean: model_level_number
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>In this tutorial we have looked at how to use the Python package <code class="language-plaintext highlighter-rouge">iris</code>: an extension of the Python language for loading common types of Earth and climate science data foramts, such as NetCDF. Iris also is a powerful software package for manipulating, analysing. and plotting the data once loaded, making it an integrated tool for Earth and climate data scientists.</p>

<h3 id="tutorial-outcomes">Tutorial outcomes:</h3>

<h4 id="1-you-understand-why-iris-is-a-useful-tool-in-the-python-community-for-dealing-with-climate-data">1. You understand why Iris is a useful tool in the Python community for dealing with climate data.</h4>

<h4 id="2-you-know-how-to-use-the-basic-load-functions-for-iris">2. You know how to use the basic load functions for Iris</h4>

<h4 id="3-you-can-create-an-iris-cube-and-understand-the-basics-of-the-data-structure">3. You can create an Iris “cube” and understand the basics of the data structure</h4>

<h4 id="4-you-can-apply-more-complex-constraints-to-loading-data-from-cubes-such-as-time-and-variable-constraints">4. You can apply more complex constraints to loading data from cubes, such as time and variable constraints.</h4>

<h4 id="5-you-understand-the-basics-of-cube-slicing">5. You understand the basics of cube slicing.</h4>

<h4 id="6-you-can-create-simple-plots-using-the-iris-plotting-interface-which-is-an-extension-of-the-matplotlib-library">6. You can create simple plots using the iris plotting interface. (Which is an extension of the <code class="language-plaintext highlighter-rouge">matplotlib</code> library.)</h4>

<hr>

<hr>

<h3><a href="https://www.surveymonkey.co.uk/r/VH6XDVZ" target="_blank" rel="noopener noreferrer">  We would love to hear your feedback, please fill out our survey!</a></h3>
<p><br></p>
<h3>  You can contact us with any questions on <a href="mailto:ourcodingclub@gmail.com?Subject=Tutorial%20question" target="_top">ourcodingclub@gmail.com</a>
</h3>
<p><br></p>
<h3>  Related tutorials:</h3>

<p><br></p>
<h3>  Subscribe to our mailing list:</h3>
<div class="container">
	<div class="block">
        <!-- subscribe form start -->
		<div class="form-group">
			<form action="https://getsimpleform.com/messages?form_api_token=de1ba2f2f947822946fb6e835437ec78" method="post">
			<div class="form-group">
				<input type="text" class="form-control" name="Email" placeholder="Email" required="">
			</div>
			<div>
                        	<button class="btn btn-default" type="submit">Subscribe</button>
                    	</div>
                	</form>
		</div>
	</div>
</div>

<ul class="social-icons">
	<li>
		<h3>
			<a href="https://twitter.com/our_codingclub" target="_blank" rel="noopener noreferrer"> Follow our coding adventures on Twitter! <i class="fa fa-twitter"></i></a>
		</h3>
	</li>
</ul>
<p>:w</p>


    	<footer class="footer">
	<hr>
	<div class="footer-container">
    	<ul class="footer-link-list">
        	<li><a href="/tutorials">Tutorials</a></li>
        	<li><a href="/team">About Us</a></li>
        	<li><a href="/contact">Contact us</a></li>
	    	<li><a href="https://twitter.com/our_codingclub" target="_blank" rel="noopener noreferrer">Follow us on Twitter</a></li>
    	</ul>
    	<div class="footer-text">
			<p>We are happy for people to use and further develop our tutorials - please give credit to Coding Club by linking to <a href="https://ourcodingclub.github.io/" target="_blank" rel="noopener noreferrer">our website</a>. We are also happy to discuss possible collaborations, so get in touch at <b>ourcodingclub@gmail.com</b></p>
    		<p>See our <a href="/terms">Terms of Use</a> and our <a href="/privacy">Data Privacy policy</a>.</p>
			<p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener noreferrer">Creative Commons Attribution-ShareAlike 4.0 International License</a></p>
			<a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener noreferrer"><img class="license" src="https://licensebuttons.net/l/by-sa/4.0/80x15.png" alt="CC-by-sa-4.0"></a>
    	</div>
    </div>
</footer>

<!-- JS -->
<script src="/scripts/owl.carousel.js"></script>
<script src="/scripts/owl.carousel-init.js"></script>
<script src="/scripts/reveal.js"></script>


	
	</body>
</html>
